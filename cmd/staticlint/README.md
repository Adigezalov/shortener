# Staticlint - Custom Multichecker

Staticlint — это кастомный статический анализатор кода Go, объединяющий множество анализаторов в один инструмент для комплексной проверки качества кода.

## Состав анализаторов

### Стандартные анализаторы (golang.org/x/tools/go/analysis/passes)

- **asmdecl** - проверка соответствия между ассемблерными файлами и Go-декларациями
- **assign** - обнаружение бесполезных присваиваний
- **atomic** - проверка использования пакета sync/atomic
- **bools** - обнаружение ошибок с булевыми операторами
- **buildtag** - проверка корректности build tags
- **cgocall** - проверка правил передачи указателей в cgo
- **composite** - проверка составных литералов без ключей
- **copylock** - обнаружение копирования мьютексов по значению
- **errorsas** - проверка корректности использования errors.As
- **httpresponse** - проверка ошибок при работе с HTTP responses
- **loopclosure** - проверка захвата переменных цикла в замыканиях
- **lostcancel** - проверка потерянных функций отмены контекста
- **nilfunc** - проверка бесполезных сравнений функций с nil
- **printf** - проверка соответствия format strings и аргументов printf
- **shadow** - обнаружение затенения переменных
- **shift** - проверка битовых сдвигов
- **sortslice** - проверка использования sort.Slice
- **stdmethods** - проверка сигнатур стандартных методов
- **stringintconv** - проверка преобразований int в string
- **structtag** - проверка тегов структур
- **tests** - проверка корректности тестов и бенчмарков
- **unmarshal** - проверка передачи указателей в unmarshal
- **unreachable** - обнаружение недостижимого кода
- **unsafeptr** - проверка использования unsafe.Pointer
- **unusedresult** - проверка неиспользуемых результатов функций

### Анализаторы Staticcheck

#### Класс SA (Static Analysis)
Все анализаторы класса SA из пакета `staticcheck.io`, обнаруживающие различные проблемы качества кода, баги и потенциальные ошибки.

#### Класс S (Simple)
Анализаторы класса S предлагают упрощения кода:
- S1000-S1999: предложения по упрощению кода

#### Класс ST (Style)
Анализаторы класса ST проверяют соответствие стилю кодирования:
- ST1000-ST1999: нарушения руководства по стилю

#### Класс QF (Quick Fix)
Анализаторы класса QF предлагают быстрые исправления:
- QF1000-QF1999: быстрые исправления распространенных проблем

### Публичные анализаторы

- **errcheck** - проверка непроверенных ошибок

### Кастомные анализаторы

#### exitcheck
Собственный анализатор, запрещающий прямые вызовы `os.Exit()` в функции `main` пакета `main`.

**Назначение:** Способствует лучшим практикам программирования:
- Правильная обработка ошибок и их распространение
- Механизмы graceful shutdown
- Лучшая тестируемость main функций
- Правильная очистка ресурсов через defer функции

**Принцип работы:** Анализатор сканирует AST на предмет прямых вызовов `os.Exit` в main функции main пакета и сообщает о них как о нарушениях.

## Использование

### Через Makefile

```bash
# Статический анализ только production кода
make staticlint

# Полный статический анализ (включая тесты)
make staticlint-full

# Комплексная проверка (включает staticlint)
make check
```

### Прямой запуск

```bash
# Сборка
go build -o staticlint ./cmd/staticlint

# Запуск на всем проекте
./staticlint ./...

# Запуск на конкретных пакетах
./staticlint ./cmd/... ./internal/...
```

### Через go run

```bash
# Анализ всего проекта
go run ./cmd/staticlint ./...

# Анализ конкретных директорий
go run ./cmd/staticlint ./cmd/shortener ./internal/handlers
```

## Механизм запуска

1. **Инициализация:** Multichecker загружает все зарегистрированные анализаторы
2. **Парсинг:** Код разбирается в Abstract Syntax Tree (AST)
3. **Анализ:** Каждый анализатор проходит по AST и ищет соответствующие паттерны
4. **Отчет:** Найденные проблемы сообщаются с указанием файла, строки и описания

## Конфигурация

Анализатор можно запускать на разных наборах файлов:

- **Production код:** `./cmd/shortener ./internal/...` (исключает тесты)
- **Все файлы:** `./...` (включает тесты и примеры)
- **Конкретные пакеты:** можно указать точные пути к пакетам

## Интеграция в CI/CD

Анализатор интегрирован в команду `make check`, что позволяет использовать его в continuous integration пайплайнах для автоматической проверки качества кода.

## Примеры найденных проблем

```go
// Нарушение exitcheck
func main() {
    if err != nil {
        os.Exit(1) // ❌ Запрещено анализатором exitcheck
    }
}

// Правильный подход
func main() {
    if err := run(); err != nil {
        log.Fatal(err) // ✅ Использует log.Fatal или возврат из main
    }
}

// Shadow violation
func example() {
    err := errors.New("original")
    if condition {
        err := errors.New("shadow") // ❌ Затенение переменной
        _ = err
    }
}

// Unchecked error
func example() {
    json.Marshal(data) // ❌ Не проверяется ошибка
}
```
